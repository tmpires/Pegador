import lejos.hardware.Button;
import lejos.hardware.motor.EV3LargeRegulatedMotor;
import lejos.hardware.port.MotorPort;
import lejos.hardware.port.SensorPort;
import lejos.hardware.sensor.EV3ColorSensor;
import lejos.hardware.sensor.EV3GyroSensor;
import lejos.robotics.SampleProvider;
import lejos.utility.Delay;

public class Navegacao implements Runnable {
	private static EV3LargeRegulatedMotor motorEsq = new EV3LargeRegulatedMotor(
			MotorPort.B);
	private static EV3LargeRegulatedMotor motorDir = new EV3LargeRegulatedMotor(
			MotorPort.C);
	public static EV3GyroSensor gyro = new EV3GyroSensor(SensorPort.S3);
	private static EV3ColorSensor sensorCorChao = new EV3ColorSensor(
			SensorPort.S4);
	// private static boolean tocado = false;
	private static final double RAIO_RODA = 0.028; // metros
	// private static final double DISTANCIA_RODAS = 0.137; // metros
	private static int velocidadeMenor = 100;
	private static int velocidadeMaior = 350;
	private static int angCurva = 90;
	public static final int LESTE = 0;
	public static final int NORTE = 1;
	public static final int OESTE = 2;
	public static final int SUL = 3;
	public static int orientacaoAtual = NORTE;
	private static double anguloAtual;
	public static boolean mudouDeSala = false;
	public static boolean virouEsq = false;
	public static boolean virouDir = false;
	private static double angAnterior;

	public Navegacao() {
		resetarTacometro();
	}

	/**
	 * anda para frente
	 */
	public static void andarFrente(double ang) {
		amostragem(); // pra que chamar esse metodo se ele ja esta rodando na thread?
		if (anguloAtual > ang + 5 || anguloAtual < ang - 5) {
			setVelocidade(velocidadeMenor);
			parar();
			while (anguloAtual > ang + 5) {
				motorEsq.forward();
				motorDir.backward();
				amostragem();
			}
			while (anguloAtual < ang - 5) {
				motorEsq.backward();
				motorDir.forward();
				amostragem();
			}
			resetarTacometro();
		}
		setVelocidade(velocidadeMaior);
		motorEsq.forward();
		motorDir.forward();
	}

	/**
	 * seta um valor para o angAnterior
	 * 
	 * @param ang
	 */
	public static void setAngAnterior(double ang) {
		angAnterior = ang;
	}

	/**
	 * retorna o angAnterior
	 * 
	 * @return angAnterior
	 */

	public static double getAngAnterior() {
		return angAnterior;
	}

	/**
	 * seta a leitura dos tacometros como zero
	 */
	public static void resetarTacometro() {
		motorEsq.resetTachoCount();
		motorDir.resetTachoCount();
	}

	public static double getAnguloAtual() {
		return anguloAtual;
	}

	/**
	 * gira em cada roda o angulo necessario para chegar na distancia
	 * requisitada
	 * 
	 * @param distancia
	 */
	public static void andarGraus(double distancia) {
		int angulo = (int) (180 * (distancia) / (Math.PI * RAIO_RODA));
		motorEsq.rotate(angulo, true);
		motorDir.rotate(angulo);
	}
	public static void andarGrausRe(double distancia){
		int angulo = (int) (180 * (distancia) / (Math.PI * RAIO_RODA));
		motorEsq.rotate(-angulo, true);
		motorDir.rotate(-angulo);
	}
	/**
	 * Para os dois motores
	 */
	public static void parar() {
		motorEsq.stop(true);
		motorDir.stop();
	}

	/**
	 * anda para trás
	 */
	public static void ré() {
		setVelocidade(velocidadeMenor);
		motorEsq.backward();
		motorDir.backward();
	}

	/**
	 * alinhar o robô na parede
	 */
	public static void alinhar() {
		setVelocidade(300);
		motorEsq.backward();
		motorDir.backward();
		Delay.msDelay(1000);
		parar();
		resetarTacometro();
	}

	/**
	 * Vira quando encontrar a parede
	 */

	// arrumar
	public static void virarParede() {
		if (orientacaoAtual == OESTE) {
			virarDuasRodasDir(angCurva, velocidadeMenor);
		} else if (orientacaoAtual == LESTE) {
			virarDuasRodasEsq(angCurva, velocidadeMenor);
		} /*
		 * else if (orientacaoAtual == NORTE) { virarDuasRodasEsq(angCurva,
		 * velocidadeMenor); } else if (orientacaoAtual == SUL) {
		 * virarDuasRodasEsq(angCurva, velocidadeMenor); }
		 */
		angAnterior = anguloAtual;
	}

	/**
	 * Vira na mesma coluna, aliando o robô na parede
	 */

	public static void virarParedeMesmaColuna() {
		if (!virouDir) {
			virarDuasRodasDir(angCurva, velocidadeMenor);
			virarDuasRodasDir(angCurva, velocidadeMenor);
		} else if (!virouEsq) {
			virarDuasRodasEsq(angCurva, velocidadeMenor);
			virarDuasRodasEsq(angCurva, velocidadeMenor);
		}
	}

	/**
	 * Vira de forma que o robô navegue em zig zag
	 */
	// arrumar
	public static void virarZigZag() {
		parar();
		if (orientacaoAtual == NORTE) {
			if (virouDir) {
				virarDuasRodasDir(angCurva, velocidadeMenor);
			} else {
				virarDuasRodasEsq(angCurva, velocidadeMenor);
			}
		} else if (orientacaoAtual == SUL) {
			if (virouEsq) {
				virarDuasRodasDir(angCurva, velocidadeMenor);
			} else {
				virarDuasRodasEsq(angCurva, velocidadeMenor);
			}
		}/*
		 * else if (orientacaoAtual == OESTE) { if (virouDir) {
		 * virarDuasRodasDir(angCurva, velocidadeMenor); } else {
		 * virarDuasRodasEsq(angCurva, velocidadeMenor); } } else if
		 * (orientacaoAtual == LESTE) { if (virouDir) {
		 * virarDuasRodasDir(angCurva, velocidadeMenor); } else {
		 * virarDuasRodasEsq(angCurva, velocidadeMenor); } }
		 */
		angAnterior = anguloAtual;
	}

	/**
	 * gira o angulo necessario com uma roda pra frente e outra pra tras em
	 * torno do eixo do robo
	 * 
	 * @param ang
	 * @param vel
	 */
	public static void virarDuasRodasEsq(int ang, int vel) {
		setVelocidade(vel);
		double anguloAnterior = anguloAtual;
		while (true) {
			amostragem(); // se tem uma thread atualizando esses valores, pra que atualizar novamente?
			
			if ((Math.abs(anguloAnterior - anguloAtual) < ang - 2)) {
				motorEsq.backward();
				motorDir.forward();
			} else if ((Math.abs(anguloAnterior - anguloAtual) > ang + 2)) {
				motorEsq.forward();
				motorDir.backward();
			} else {
				parar();
				break;
			}
		}
		virouEsq = true;
		virouDir = false;
		resetarTacometro();
		proximaDirecao();
		angAnterior = anguloAtual;
	}

	/**
	 * gira o angulo necessario com uma roda pra frente e outra pra tras em
	 * torno do eixo do robo
	 * 
	 * @param ang
	 * @param vel
	 */
	public static void virarDuasRodasDir(int ang, int vel) {
		setVelocidade(vel);
		double anguloAnterior = anguloAtual;
		while (true) {
			amostragem();
			if ((Math.abs(anguloAnterior - anguloAtual) < ang - 2)) {
				motorEsq.forward();
				motorDir.backward();
			} else if ((Math.abs(anguloAnterior - anguloAtual) > ang + 2)) {
				motorEsq.backward();
				motorDir.forward();
			} else {
				parar();
				break;
			}
		}
		virouDir = true;
		virouEsq = false;
		resetarTacometro();
		proximaDirecao();
		angAnterior = anguloAtual;
	}

	/**
	 * anda para frente até que mude de sala
	 */
	public static void irProxSala() {
		setVelocidade(2 * velocidadeMenor);
		double anguloAnterior = anguloAtual;
		while (!mudouDeSala)
			andarFrente(anguloAnterior);
		resetarTacometro();
	}

	/**
	 * seta velocidade nos dois motores
	 * 
	 * @param vel
	 */
	public static void setVelocidade(int vel) {
		motorEsq.setSpeed(vel);
		motorDir.setSpeed(vel);
	}

	/**
	 * retorna a distancia percorrida pelo robô de acordo com o tacometro
	 * 
	 * @return distancia percorrida
	 */
	public static double getDistPercorrida() {
		double angEsq = motorEsq.getTachoCount();
		double dist = RAIO_RODA * angEsq * (Math.PI / 180);
		return dist;
	}

	/**
	 * Leitura dos sensores
	 */
	private static void amostragem() {
		SampleProvider corChao = sensorCorChao.getColorIDMode();
		float amostraCorChao[] = new float[corChao.sampleSize()];
		corChao.fetchSample(amostraCorChao, 0);

		SampleProvider Gyro = gyro.getAngleMode();
		float amostraGyro[] = new float[Gyro.sampleSize()];
		Gyro.fetchSample(amostraGyro, 0);
		anguloAtual = amostraGyro[0];

		if (amostraCorChao[0] == 6) // Branco
			mudouDeSala = false;
		else if (amostraCorChao[0] == 7) // Preto
			mudouDeSala = true;
	}

	/**
	 * Atualiza a direção de acordo com o sentido que o robo virou
	 */

	public static void proximaDirecao() {
		switch (orientacaoAtual) {
		case NORTE:
			if (virouEsq)
				orientacaoAtual = OESTE;
			else if (virouDir)
				orientacaoAtual = LESTE;
			break;
		case SUL:
			if (virouEsq)
				orientacaoAtual = LESTE;
			else if (virouDir)
				orientacaoAtual = OESTE;
			break;
		case LESTE:
			if (virouEsq)
				orientacaoAtual = NORTE;
			else if (virouDir)
				orientacaoAtual = SUL;
			break;
		case OESTE:
			if (virouEsq)
				orientacaoAtual = SUL;
			else if (virouDir)
				orientacaoAtual = NORTE;
			break;
		default:
			break;
		}
	}

	@Override
	public void run() {
		while (!Button.ESCAPE.isDown()) {
			amostragem();
		}
	}
}
