package testeParede;

import java.util.List;

import lejos.hardware.Button;
import lejos.hardware.Sound;
import lejos.utility.Delay;

public class Mapeamento {
	private static Posicao ultMapeadaCentral;
	private static Posicao ultMapeadaPeriferica;
	private static Posicao atual;
	private static int ultOrientacaoCentral;
	private static int ultOrientacaoPeriferica;
	private static int numLinhas = 9;
	private static int numColunas = 9;
	private static Celula[][] Mapa = new Celula[numLinhas][numColunas];
	private static Celula[][] MapaCentral = new Celula[numLinhas][numColunas];
	private static Celula[][] MapaPeriferico1 = new Celula[numLinhas][numColunas];
	private static Celula[][] MapaPeriferico2 = new Celula[numLinhas][numColunas];
	private static int linhaInicial = 4;
	private static int colunaInicial = 0;
	private static int linha = linhaInicial;
	private static int coluna = colunaInicial;
	private static Posicao inicio = new Posicao(linhaInicial, colunaInicial);
	private static Posicao porta = new Posicao(linhaInicial, colunaInicial);

	public static int vazio = 0;
	public static int bonecoPreto = 1;
	public static int bonecoNaoPreto = 2;
	public static boolean virouEsq = false;
	public static boolean primeiraCurva = true;
	public static double tamanhoDaCelula = 0.19;
	private static boolean estaNaParede = false;
	private static boolean estaNaPorta = false;
	private static boolean celulaEsq = false;
	private static boolean celulaDir = false;
	private static boolean celulaBaixo = false;
	private static boolean celulaCima = false;
	private static boolean resgatando = false;
	private static boolean retornandoMapeamento = false;
	private static int velocidadeMaior = 350;
	private static int velocidadeMenor = 100;
	private static int angCurva = 87;
	private static boolean mapearZigZag = false;
	public static final int MODULOINICIAL = 0;
	public static final int SALACENTRAL = 1;
	public static final int SALAPERIFERICA = 2;
	public static int salaAtual = MODULOINICIAL;
	public static int ultSala;
	private static boolean perifericaDireita = false;
	private static boolean perifericaEsquerda = false;
	private static double minimoDiagonal = 0.5;
	private static double minimoReta = 0.4;
	private static Celula[] paredeAleatoria = new Celula[7];
	private static boolean paredeEncontrada = false;
	private static boolean virarParedeAleatoria;

	/**
	 * Verificar se a celula foi checada, caso não, salva o conteudo na matriz.
	 * Se houver um boneco preto chama o método de resgate
	 */
	public static void checarCelulas() throws Exception {
		int conteudo = verificarConteudo();
		if (conteudo == vazio) {
			Mapa[linha][coluna].setOccupied(false);
		} else if (conteudo == bonecoPreto) {
			Navegacao.parar();
			Mapa[linha][coluna].setOccupied(false);
			resgatando = true;
			mapearZigZag = false;
			if (salaAtual == SALACENTRAL)
				retornar(inicio);
			else
				retornar(porta);
			mapearZigZag = true;
		} else if (conteudo == bonecoNaoPreto) {
			Navegacao.parar();
			moverBonecoBranco();
			Navegacao.setVelocidade(velocidadeMaior);
		}
	}

	/**
	 * Leva o boneco branco para a celula mais proxima que está vazia
	 * 
	 * @throws Exception
	 */

	public static void moverBonecoBranco() throws Exception {
		if (coluna > 0 && !Mapa[linha][coluna - 1].isOccupied()
				&& (linha != linhaInicial && (coluna - 1) != colunaInicial)) {
			resetarProxCelulas();
			ultOrientacaoCentral = Navegacao.orientacaoAtual;
			Mapa[linha][coluna - 1].setOccupied(true);
			celulaBaixo = true;
		} else if (linha < numLinhas - 1
				&& !Mapa[linha + 1][coluna].isOccupied()
				&& ((linha + 1) != linhaInicial && coluna != colunaInicial)) {
			resetarProxCelulas();
			ultOrientacaoCentral = Navegacao.orientacaoAtual;
			Mapa[linha + 1][coluna].setOccupied(true);
			celulaDir = true;
		} else if (linha > 0 && !Mapa[linha - 1][coluna].isOccupied()
				&& ((linha - 1) != linhaInicial && coluna != colunaInicial)) {
			resetarProxCelulas();
			ultOrientacaoCentral = Navegacao.orientacaoAtual;
			Mapa[linha - 1][coluna].setOccupied(true);
			celulaEsq = true;
		} else if (coluna < numColunas - 1
				&& !Mapa[linha][coluna + 1].isOccupied()
				&& (linha != linhaInicial && (coluna - 1) != colunaInicial)) {
			resetarProxCelulas();
			ultOrientacaoCentral = Navegacao.orientacaoAtual;
			Mapa[linha][coluna + 1].setOccupied(true);
			celulaCima = true;
		} else {
			irProximaCelula();
			atualizarCelulas();
			resetarProxCelulas();
			ultOrientacaoCentral = Navegacao.orientacaoAtual;
			if (Navegacao.orientacaoAtual == Navegacao.OESTE) {
				celulaDir = true;
				Mapa[linha + 1][coluna].setOccupied(true);
			} else if (Navegacao.orientacaoAtual == Navegacao.LESTE) {
				celulaEsq = true;
				Mapa[linha - 1][coluna].setOccupied(true);
			}
		}
		fazerManobra();
		Navegacao.andarGraus(tamanhoDaCelula / 2);
		Captura.abrirGarra();
		Navegacao.andarGraus(-tamanhoDaCelula / 2);
		mudarOrientacao(ultOrientacaoCentral);
		resetarProxCelulas();
	}

	/**
	 * seta o mapeamento da sala como zigzag
	 * 
	 * @param boolean zigzag
	 */
	public static void setMapearZigZag(boolean zigzag) {
		mapearZigZag = zigzag;
	}

	/**
	 * Navega até a sala periferica à frente
	 * 
	 * @throws Exception
	 */
	public static void irPerifericaFrente() throws Exception {
		while (salaAtual != SALAPERIFERICA) {
			irProximaCelula();
			checarCelulas();
			atualizarCelulas();
			if (Navegacao.mudouDeSala) {
				atualizarSala();
				perifericaDireita = false;
				perifericaEsquerda = false;
			}
		}
	}

	/**
	 * Navega até a sala periferica à Direita
	 * 
	 * @throws Exception
	 */
	public static void irPerifericaDireita() throws Exception {
		while (salaAtual != SALAPERIFERICA) {
			irProximaCelula();
			checarCelulas();
			atualizarCelulas();
			if (coluna == ((numColunas - 1) / 2) && !Navegacao.virouDir) {
				Delay.msDelay(500);
				Navegacao.parar();
				Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
				irProximaCelula();
				checarCelulas();
			}
			if (Navegacao.mudouDeSala) {
				perifericaDireita = true;
				perifericaEsquerda = false;
				atualizarSala();
			}
		}
	}

	/**
	 * Navega até a sala periferica à Esquerda
	 * 
	 * @throws Exception
	 */
	public static void irPerifericaEsquerda() throws Exception {
		while (salaAtual != SALAPERIFERICA) {
			irProximaCelula();
			checarCelulas();
			atualizarCelulas();
			if (coluna == ((numColunas - 1) / 2) && !Navegacao.virouEsq) {
				Delay.msDelay(500);
				Navegacao.parar();
				Navegacao.virarDuasRodasEsq(angCurva, velocidadeMenor);
				irProximaCelula();
				checarCelulas();
			}
			if (Navegacao.mudouDeSala) {
				perifericaDireita = false;
				perifericaEsquerda = true;
				atualizarSala();
			}
		}
	}

	/**
	 * Atualiza para a proxima celula dependendo da orientacao do robo Caso ele
	 * esteja na parede, realiza a manobra de virar
	 * 
	 * @throws Exception
	 */

	public static void atualizarCelulas() throws Exception {
		switch (Navegacao.orientacaoAtual) {
		case Navegacao.LESTE:
			if (linha < numLinhas)
				linha++;
			System.out.println("LESTE");
			if ((!resgatando && !retornandoMapeamento && mapearZigZag && (perifericaDireita || perifericaEsquerda)))
				Navegacao.virarZigZag();
			break;
		case Navegacao.OESTE:
			System.out.println("OESTE");
			if (linha > 0)
				linha--;
			if ((!resgatando && !retornandoMapeamento && mapearZigZag && (perifericaDireita || perifericaEsquerda)))
				Navegacao.virarZigZag();
			break;
		case Navegacao.NORTE:
			if (coluna < numColunas)
				coluna++;
			System.out.println("NORTE");
			if ((!resgatando && !retornandoMapeamento && mapearZigZag
					&& !perifericaDireita && !perifericaEsquerda))
				Navegacao.virarZigZag();
			break;
		case Navegacao.SUL:
			if (coluna >= 0)
				coluna--;
			System.out.println("SUL");
			if ((!resgatando && !retornandoMapeamento && mapearZigZag
					&& !perifericaDireita && !perifericaEsquerda))
				Navegacao.virarZigZag();
			break;
		default:
			break;
		}
		System.out.println("[" + linha + ", " + coluna + "]");

		if ((paredeAleatoria[0].temParede() && linha == 4
				&& Navegacao.orientacaoAtual == Navegacao.OESTE && coluna <= 3)
				|| (paredeAleatoria[1].temParede() && linha == 4
						&& Navegacao.orientacaoAtual == Navegacao.LESTE && coluna <= 3)) {
			if (coluna == 3) {
				mapearProximoParede();
			} else {
				virarParedeAleatoria = true;
			}
		} else {
			virarParedeAleatoria = false;
		}

		if (((linha == 0 && Navegacao.orientacaoAtual == Navegacao.OESTE)
				|| (linha == 8 && Navegacao.orientacaoAtual == Navegacao.LESTE)
				|| (coluna == 8 && Navegacao.orientacaoAtual == Navegacao.NORTE) || (coluna == 0 && Navegacao.orientacaoAtual == Navegacao.SUL))
				|| virarParedeAleatoria) {
			estaNaParede = true;
			Sound.beep();
		} else {
			estaNaParede = false;
		}

		if (((linha == 0 && Navegacao.orientacaoAtual == Navegacao.LESTE)
				|| (linha == 8 && Navegacao.orientacaoAtual == Navegacao.OESTE)
				|| (coluna == 8 && Navegacao.orientacaoAtual == Navegacao.SUL) || (coluna == 0 && Navegacao.orientacaoAtual == Navegacao.NORTE))
				&& linha != 4) {
			Navegacao.alinhar();
			Navegacao.setAngAnterior(Navegacao.getAnguloAtual());
		}

		if ((linha == 0 && coluna == 4 && Navegacao.orientacaoAtual == Navegacao.OESTE)
				|| (linha == 8 && coluna == 4 && Navegacao.orientacaoAtual == Navegacao.LESTE)
				|| (coluna == 8 && linha == 4 && Navegacao.orientacaoAtual == Navegacao.NORTE)
				|| (coluna == 0 && linha == 4 && Navegacao.orientacaoAtual == Navegacao.SUL))
			estaNaPorta = true;
		else
			estaNaPorta = false;

		if (estaNaParede && (Mapa[linha][coluna].getPosicao() != inicio)
				&& mapearZigZag) {
			Navegacao.parar();
			Navegacao.ré();
			Delay.msDelay(800);
			if (!resgatando) {
				Navegacao.virarParede();
				if (primeiraCurva) {
					Navegacao.alinhar();
					Navegacao.setAngAnterior(Navegacao.getAnguloAtual());
					primeiraCurva = false;
				}
			}
		}

		/*
		 * if (estaNaPorta && salaAtual == SALACENTRAL) { checarCelulas();
		 * Navegacao.irProxSala(); }
		 */
		Navegacao.resetarTacometro();
	}

	/**
	 * Inicia as celulas que podem conter a parede
	 */

	public static void inicializarParedes() {
		paredeAleatoria[0] = Mapa[2][1];
		paredeAleatoria[1] = Mapa[6][1];
		paredeAleatoria[2] = Mapa[6][3];
		paredeAleatoria[3] = Mapa[2][3];
		paredeAleatoria[4] = Mapa[1][6];
		paredeAleatoria[5] = Mapa[3][6];
		paredeAleatoria[6] = Mapa[7][6];
	}

	/**
	 * Procura a parede nas suas possiveis posições
	 * 
	 * @throws Exception
	 */
	public static void procurarParede() throws Exception {
		while (coluna < paredeAleatoria[0].getPosicao().y) {
			checarCelulas();
			irProximaCelula();
			checarCelulas();
			atualizarCelulas();
			checarCelulas();
		}
		checarCelulas();
		mudarOrientacao(Navegacao.OESTE);
		while (linha > paredeAleatoria[0].getPosicao().x) {
			checarCelulas();
			irProximaCelula();
			atualizarCelulas();
		}
		Navegacao.parar();
		movimentoProcuraParede(); // Procura a parede diagonal esquerda baixo
		if (!paredeEncontrada) {
			mudarOrientacao(Navegacao.LESTE);
			while (linha < paredeAleatoria[1].getPosicao().x) {
				checarCelulas();
				irProximaCelula();
				atualizarCelulas();
			}
			Navegacao.parar();
			movimentoProcuraParede(); // Procura a parede diagonal direita baixo
		} else {
			mapearProximoParede();
			retornar(inicio);
			mudarOrientacao(Navegacao.LESTE);
			setMapearZigZag(true);
		}
		if (!paredeEncontrada) {
			Mapeamento.mudarOrientacao(Navegacao.OESTE);
			Mapeamento.atualizarCelulas();
			Mapeamento.irProximaCelula();
			Mapeamento.atualizarCelulas();
			Mapeamento.irProximaCelula();
			Mapeamento.atualizarCelulas();
			Mapeamento.mudarOrientacao(Navegacao.SUL);
			Mapeamento.irProximaCelula();
			Mapeamento.atualizarCelulas();
			Navegacao.parar();
			Navegacao.ré();
			Delay.msDelay(1000);
			Mapeamento.mudarOrientacao(Navegacao.LESTE);
			Mapeamento.setMapearZigZag(true);

			while (Mapa[linha][coluna].getPosicao() != Mapa[8][3].getPosicao()) {
				Mapeamento.checarCelulas();
				Mapeamento.irProximaCelula();
				Mapeamento.atualizarCelulas();
			}
			mudarOrientacao(Navegacao.OESTE);
			while (linha > paredeAleatoria[2].getPosicao().x) {
				checarCelulas();
				irProximaCelula();
				atualizarCelulas();
			}
			mudarOrientacao(Navegacao.NORTE);
			movimentoProcuraParede(); // Procura a parede Reta direita meio
			if (!paredeEncontrada) {
				mudarOrientacao(Navegacao.OESTE);
				while (linha > paredeAleatoria[3].getPosicao().x) {
					checarCelulas();
					irProximaCelula();
					atualizarCelulas();
				}
				mudarOrientacao(Navegacao.NORTE);
				movimentoProcuraParede(); // Procura a parede Reta esquerda meio
				if (!paredeEncontrada) {
					mudarOrientacao(Navegacao.OESTE);
					while (Mapa[linha][coluna].getPosicao() != Mapa[0][3]
							.getPosicao()) {
						Mapeamento.checarCelulas();
						Mapeamento.irProximaCelula();
						Mapeamento.atualizarCelulas();
					}
					setMapearZigZag(false);
					mudarOrientacao(Navegacao.NORTE);
					while (coluna < paredeAleatoria[4].getPosicao().y) {
						checarCelulas();
						irProximaCelula();
						atualizarCelulas();
					}
					mudarOrientacao(Navegacao.LESTE);
					Navegacao.alinhar();
					while (linha < paredeAleatoria[4].getPosicao().x) {
						checarCelulas();
						irProximaCelula();
						atualizarCelulas();
					}
					movimentoProcuraParede(); // Procura a parede diagonal
												// esquerda cima
					if (!paredeEncontrada) {
						mudarOrientacao(Navegacao.LESTE);
						while (linha < paredeAleatoria[5].getPosicao().x) {
							checarCelulas();
							irProximaCelula();
							atualizarCelulas();
						}
						movimentoProcuraParede(); // Procura a parede reta cima
						if (!paredeEncontrada)
							setarParede(paredeAleatoria[6].getPosicao());
					} else {
						retornar(Mapa[0][4].getPosicao());
						setMapearZigZag(true);
					}
				} else {
					mudarOrientacao(Navegacao.OESTE);
					setMapearZigZag(true);
				}
			} else {
				mapearProximoParede();
			}
		} else {
			mapearProximoParede();
			retornar(inicio);
			mudarOrientacao(Navegacao.OESTE);
			setMapearZigZag(true);
		}
	}

	/**
	 * Faz o movimento para procurar a parede
	 */
	private static void movimentoProcuraParede() {
		if (Navegacao.orientacaoAtual == Navegacao.OESTE) {
			if (Reconhecimento.getDistancia() < minimoDiagonal) {
				Navegacao.virarDuasRodasDir(40, velocidadeMenor);
				if (Reconhecimento.getDistancia() < minimoDiagonal) {
					Navegacao.virarDuasRodasDir(40, velocidadeMenor);
					if (Reconhecimento.getDistancia() < minimoDiagonal) {
						Button.LEDPattern(4);
						paredeEncontrada = true;
						setarParede(Mapa[linha][coluna].getPosicao());
						Navegacao.virarDuasRodasEsq(40, velocidadeMenor);
						Navegacao.virarDuasRodasEsq(40, velocidadeMenor);
					} else {
						Navegacao.virarDuasRodasEsq(40, velocidadeMenor);
						Navegacao.virarDuasRodasEsq(40, velocidadeMenor);
					}
				} else {
					Navegacao.virarDuasRodasEsq(40, velocidadeMenor);
				}
			}
		} else if (Navegacao.orientacaoAtual == Navegacao.LESTE
				&& Mapa[linha][coluna].getPosicao() != paredeAleatoria[5]
						.getPosicao()) {
			if (Reconhecimento.getDistancia() < minimoDiagonal) {
				Navegacao.virarDuasRodasEsq(40, velocidadeMenor);
				if (Reconhecimento.getDistancia() < minimoDiagonal) {
					Navegacao.virarDuasRodasEsq(40, velocidadeMenor);
					if (Reconhecimento.getDistancia() < minimoDiagonal) {
						Button.LEDPattern(4);
						paredeEncontrada = true;
						setarParede(Mapa[linha][coluna].getPosicao());
						Navegacao.virarDuasRodasDir(40, velocidadeMenor);
						Navegacao.virarDuasRodasDir(40, velocidadeMenor);
					} else {
						Navegacao.virarDuasRodasDir(40, velocidadeMenor);
						Navegacao.virarDuasRodasDir(40, velocidadeMenor);
					}
				} else {
					Navegacao.virarDuasRodasDir(40, velocidadeMenor);
				}
			}
		} else if (Navegacao.orientacaoAtual == Navegacao.NORTE
				|| Mapa[linha][coluna].getPosicao() == paredeAleatoria[5]
						.getPosicao()) {
			if (Reconhecimento.getDistancia() < minimoReta) {
				Navegacao.virarDuasRodasEsq(30, velocidadeMenor);
				if (Reconhecimento.getDistancia() < minimoReta) {
					Navegacao.virarDuasRodasDir(30, velocidadeMenor);
					Navegacao.virarDuasRodasDir(30, velocidadeMenor);
					if (Reconhecimento.getDistancia() < minimoReta) {
						Button.LEDPattern(4);
						paredeEncontrada = true;
						setarParede(Mapa[linha][coluna].getPosicao());
						Navegacao.virarDuasRodasEsq(30, velocidadeMenor);
					} else {
						Navegacao.virarDuasRodasEsq(30, velocidadeMenor);
					}
				} else {
					Navegacao.virarDuasRodasDir(30, velocidadeMenor);
				}
			}
		}
	}

	/**
	 * Mapear celulas ao redor da parede aleatoria
	 * 
	 * @throws Exception
	 */

	private static void mapearProximoParede() throws Exception {
		if (paredeAleatoria[0].temParede()) {
			if (coluna == 3) {
				setMapearZigZag(false);
				mudarOrientacao(Navegacao.NORTE);
				checarCelulas();
				irProximaCelula();
				atualizarCelulas();
				mudarOrientacao(Navegacao.OESTE);
				checarCelulas();
				irProximaCelula();
				atualizarCelulas();
				checarCelulas();
				irProximaCelula();
				atualizarCelulas();
				mudarOrientacao(Navegacao.SUL);
				checarCelulas();
				irProximaCelula();
				atualizarCelulas();
				mudarOrientacao(Navegacao.OESTE);
				checarCelulas();
				irProximaCelula();
				atualizarCelulas();
				mudarOrientacao(Navegacao.SUL);
				checarCelulas();
				irProximaCelula();
				atualizarCelulas();
				mudarOrientacao(Navegacao.OESTE);
				checarCelulas();
				irProximaCelula();
				atualizarCelulas();
				mudarOrientacao(Navegacao.NORTE);
				while (coluna < 4) {
					checarCelulas();
					irProximaCelula();
					atualizarCelulas();
				}
				mudarOrientacao(Navegacao.LESTE);
				setMapearZigZag(true);
			} else {
				mudarOrientacao(Navegacao.SUL);
				irProximaCelula();
				checarCelulas();
				atualizarCelulas();
				mudarOrientacao(Navegacao.OESTE);
				irProximaCelula();
				checarCelulas();
				atualizarCelulas();
				Navegacao.parar();
				Navegacao.setVelocidade(velocidadeMenor);
				Navegacao.andarGraus(-tamanhoDaCelula);
				Navegacao.setVelocidade(velocidadeMaior);
				Navegacao.resetarTacometro();
				linha++;
				Navegacao.parar();
				Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
				Navegacao.alinhar();
				Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
				irProximaCelula();
				checarCelulas();
				atualizarCelulas();
				mudarOrientacao(Navegacao.SUL);
				irProximaCelula();
				checarCelulas();
				atualizarCelulas();
				mudarOrientacao(Navegacao.OESTE);
				irProximaCelula();
				checarCelulas();
				atualizarCelulas();
				Navegacao.parar();
				Navegacao.setVelocidade(velocidadeMenor);
				Navegacao.andarGraus(-tamanhoDaCelula);
				Navegacao.setVelocidade(velocidadeMaior);
				Navegacao.resetarTacometro();
				linha++;
				Navegacao.parar();
				Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
				Navegacao.alinhar();
				Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
				irProximaCelula();
				checarCelulas();
				atualizarCelulas();

			}
		} else if (paredeAleatoria[1].temParede()) {
			if (coluna == 3) {
				setMapearZigZag(false);
				mudarOrientacao(Navegacao.NORTE);
				checarCelulas();
				irProximaCelula();
				atualizarCelulas();
				mudarOrientacao(Navegacao.LESTE);
				checarCelulas();
				irProximaCelula();
				atualizarCelulas();
				checarCelulas();
				irProximaCelula();
				atualizarCelulas();
				mudarOrientacao(Navegacao.SUL);
				checarCelulas();
				irProximaCelula();
				atualizarCelulas();
				mudarOrientacao(Navegacao.LESTE);
				checarCelulas();
				irProximaCelula();
				atualizarCelulas();
				mudarOrientacao(Navegacao.SUL);
				checarCelulas();
				irProximaCelula();
				atualizarCelulas();
				mudarOrientacao(Navegacao.LESTE);
				checarCelulas();
				irProximaCelula();
				atualizarCelulas();
				mudarOrientacao(Navegacao.NORTE);
				while (coluna < 4) {
					checarCelulas();
					irProximaCelula();
					atualizarCelulas();
				}
				mudarOrientacao(Navegacao.OESTE);
				setMapearZigZag(true);
			} else {
				mudarOrientacao(Navegacao.SUL);
				irProximaCelula();
				checarCelulas();
				atualizarCelulas();
				mudarOrientacao(Navegacao.LESTE);
				irProximaCelula();
				checarCelulas();
				atualizarCelulas();
				Navegacao.parar();
				Navegacao.setVelocidade(velocidadeMenor);
				Navegacao.andarGraus(-tamanhoDaCelula);
				Navegacao.setVelocidade(velocidadeMaior);
				Navegacao.resetarTacometro();
				linha--;
				Navegacao.parar();
				Navegacao.virarDuasRodasEsq(angCurva, velocidadeMenor);
				Navegacao.alinhar();
				Navegacao.virarDuasRodasEsq(angCurva, velocidadeMenor);
				irProximaCelula();
				checarCelulas();
				atualizarCelulas();
			}
		} else if (paredeAleatoria[2].temParede()) {
			mudarOrientacao(Navegacao.OESTE);
			while (linha > 0) {
				checarCelulas();
				irProximaCelula();
				atualizarCelulas();
			}
			mudarOrientacao(Navegacao.NORTE);
			checarCelulas();
			irProximaCelula();
			atualizarCelulas();
			mudarOrientacao(Navegacao.LESTE);
			while(linha < 3){
				checarCelulas();
				irProximaCelula();
				atualizarCelulas();
			}
			mudarOrientacao(Navegacao.NORTE);
			checarCelulas();
			irProximaCelula();
			atualizarCelulas();
			mudarOrientacao(Navegacao.OESTE);
			while (linha > 0) {
				checarCelulas();
				irProximaCelula();
				atualizarCelulas();
			}
			mudarOrientacao(Navegacao.LESTE);
			Navegacao.alinhar();
			setMapearZigZag(true);
		} else if(paredeAleatoria[3].temParede()){
			mudarOrientacao(Navegacao.OESTE);
			while (linha > 0) {
				checarCelulas();
				irProximaCelula();
				atualizarCelulas();
			}
			mudarOrientacao(Navegacao.LESTE);
			while(linha < 5){
				checarCelulas();
				irProximaCelula();
				atualizarCelulas();
			}
			mudarOrientacao(Navegacao.NORTE);
			checarCelulas();
			irProximaCelula();
			atualizarCelulas();
			mudarOrientacao(Navegacao.LESTE);
			while(linha < 8){
				checarCelulas();
				irProximaCelula();
				atualizarCelulas();
			}
			mudarOrientacao(Navegacao.NORTE);
			checarCelulas();
			irProximaCelula();
			atualizarCelulas();
			mudarOrientacao(Navegacao.OESTE);
			Navegacao.alinhar();
			setMapearZigZag(true);
		}
	}

	/**
	 * seta como ocupado as celulas que contem a parede
	 * 
	 * @param posicao
	 */

	private static void setarParede(Posicao posicao) {
		if (posicao.x == paredeAleatoria[0].getPosicao().x
				&& posicao.y == paredeAleatoria[0].getPosicao().y) {
			paredeAleatoria[0].setParede(true);
			Mapa[0][0].setChecked(true);
			Mapa[0][0].setOccupied(true);
			Mapa[0][0].setParede(true);
			Mapa[1][1].setChecked(true);
			Mapa[1][1].setOccupied(true);
			Mapa[1][1].setParede(true);
			Mapa[2][2].setChecked(true);
			Mapa[2][2].setOccupied(true);
			Mapa[2][2].setParede(true);
			Mapa[3][3].setChecked(true);
			Mapa[3][3].setOccupied(true);
			Mapa[3][3].setParede(true);
		} else if (posicao.x == paredeAleatoria[1].getPosicao().x
				&& posicao.y == paredeAleatoria[1].getPosicao().y) {
			paredeAleatoria[1].setParede(true);
			Mapa[8][0].setChecked(true);
			Mapa[8][0].setOccupied(true);
			Mapa[8][0].setParede(true);
			Mapa[7][1].setChecked(true);
			Mapa[7][1].setOccupied(true);
			Mapa[7][1].setParede(true);
			Mapa[6][2].setChecked(true);
			Mapa[6][2].setOccupied(true);
			Mapa[6][2].setParede(true);
			Mapa[5][3].setChecked(true);
			Mapa[5][3].setOccupied(true);
			Mapa[5][3].setParede(true);
		} else if (posicao.x == paredeAleatoria[2].getPosicao().x
				&& posicao.y == paredeAleatoria[2].getPosicao().y) {
			paredeAleatoria[2].setParede(true);
			Mapa[8][4].setChecked(true);
			Mapa[8][4].setOccupied(true);
			Mapa[8][4].setParede(true);
			Mapa[7][4].setChecked(true);
			Mapa[7][4].setOccupied(true);
			Mapa[7][4].setParede(true);
			Mapa[6][4].setChecked(true);
			Mapa[6][4].setOccupied(true);
			Mapa[6][4].setParede(true);
			Mapa[5][4].setChecked(true);
			Mapa[5][4].setOccupied(true);
			Mapa[5][4].setParede(true);
			Mapa[4][4].setChecked(true);
			Mapa[4][4].setOccupied(true);
			Mapa[4][4].setParede(true);
		} else if (posicao.x == paredeAleatoria[3].getPosicao().x
				&& posicao.y == paredeAleatoria[3].getPosicao().y) {
			paredeAleatoria[3].setParede(true);
			Mapa[0][4].setChecked(true);
			Mapa[0][4].setOccupied(true);
			Mapa[0][4].setParede(true);
			Mapa[1][4].setChecked(true);
			Mapa[1][4].setOccupied(true);
			Mapa[1][4].setParede(true);
			Mapa[2][4].setChecked(true);
			Mapa[2][4].setOccupied(true);
			Mapa[2][4].setParede(true);
			Mapa[3][4].setChecked(true);
			Mapa[3][4].setOccupied(true);
			Mapa[3][4].setParede(true);
			Mapa[4][4].setChecked(true);
			Mapa[4][4].setOccupied(true);
			Mapa[4][4].setParede(true);
		} else if (posicao.x == paredeAleatoria[4].getPosicao().x
				&& posicao.y == paredeAleatoria[4].getPosicao().y) {
			paredeAleatoria[4].setParede(true);
			Mapa[0][8].setChecked(true);
			Mapa[0][8].setOccupied(true);
			Mapa[0][8].setParede(true);
			Mapa[1][7].setChecked(true);
			Mapa[1][7].setOccupied(true);
			Mapa[1][7].setParede(true);
			Mapa[2][6].setChecked(true);
			Mapa[2][6].setOccupied(true);
			Mapa[2][6].setParede(true);
			Mapa[3][5].setChecked(true);
			Mapa[3][5].setParede(true);
			Mapa[3][5].setOccupied(true);
		} else if (posicao.x == paredeAleatoria[5].getPosicao().x
				&& posicao.y == paredeAleatoria[5].getPosicao().y) {
			paredeAleatoria[5].setParede(true);
			Mapa[4][8].setChecked(true);
			Mapa[4][8].setOccupied(true);
			Mapa[4][8].setParede(true);
			Mapa[4][7].setChecked(true);
			Mapa[4][7].setOccupied(true);
			Mapa[4][7].setParede(true);
			Mapa[4][6].setChecked(true);
			Mapa[4][6].setOccupied(true);
			Mapa[4][6].setParede(true);
			Mapa[4][5].setChecked(true);
			Mapa[4][5].setParede(true);
			Mapa[4][5].setOccupied(true);
			Mapa[4][4].setChecked(true);
			Mapa[4][4].setParede(true);
			Mapa[4][4].setOccupied(true);
		} else if (posicao.x == paredeAleatoria[6].getPosicao().x
				&& posicao.y == paredeAleatoria[6].getPosicao().y) {
			paredeAleatoria[6].setParede(true);
			Mapa[8][8].setChecked(true);
			Mapa[8][8].setOccupied(true);
			Mapa[8][8].setParede(true);
			Mapa[7][7].setChecked(true);
			Mapa[7][7].setOccupied(true);
			Mapa[7][7].setParede(true);
			Mapa[6][6].setChecked(true);
			Mapa[6][6].setOccupied(true);
			Mapa[6][6].setParede(true);
			Mapa[5][5].setChecked(true);
			Mapa[5][5].setParede(true);
			Mapa[5][5].setOccupied(true);
		}
	}

	/**
	 * Atualiza para a matriz da proxima sala
	 */
	public static void atualizarSala() {
		switch (salaAtual) {
		case MODULOINICIAL:
			salaAtual = SALACENTRAL;
			linha = linhaInicial;
			coluna = colunaInicial;
			Mapa = MapaCentral;
			System.out.println("SALA CENTRAL");
			break;
		case SALACENTRAL:
			MapaCentral = Mapa;
			if (Navegacao.orientacaoAtual == Navegacao.SUL) {
				salaAtual = MODULOINICIAL;
				System.out.println("MODULO INICIAL");
			} else {
				salaAtual = SALAPERIFERICA;
				Mapa = MapaPeriferico1;
				if (perifericaDireita) {
					linha = 0;
					coluna = (numColunas - 1) / 2;
				} else if (perifericaEsquerda) {
					linha = numLinhas - 1;
					coluna = (numColunas - 1) / 2;
				} else {
					linha = linhaInicial;
					coluna = colunaInicial;
				}
				System.out.println("SALA PERIFERICA");
				porta = Mapa[linha][coluna].getPosicao();
			}
			break;
		case SALAPERIFERICA:
			MapaPeriferico1 = Mapa;
			salaAtual = SALACENTRAL;
			Mapa = MapaCentral;
			if (perifericaDireita) {
				linha = numLinhas - 1;
				coluna = (numColunas - 1) / 2;
			} else if (perifericaEsquerda) {
				linha = 0;
				coluna = (numColunas - 1) / 2;
			} else {
				linha = linhaInicial;
				coluna = numColunas - 1;
			}
			System.out.println("SALA CENTRAL");
			break;
		}
		/*
		 * Navegacao.parar(); while (!Button.UP.isDown()) {
		 * System.out.println("APERTE CIMA PARA RETORNAR"); }
		 * Delay.msDelay(500);
		 */
	}

	/**
	 * verificar o que há na celula
	 * 
	 * @return Conteudo da celula
	 * @throws Exception
	 */

	private static int verificarConteudo() throws Exception {
		if (Reconhecimento.getDistancia() <= 0.1 && Captura.getGarraAberta()
				&& !estaNaParede) {
			// se houver algo alem da parede a 15 cm
			Navegacao.setVelocidade(velocidadeMenor);
			double distanciaBoneco = Reconhecimento.getDistancia();
			Navegacao.andarGraus(distanciaBoneco - 0.05);
			// andar o quanto falta para chegar no alvo
			Navegacao.parar();
			Captura.fecharGarra();
			if (!Reconhecimento.getPreto()) {
				Button.LEDPattern(2);
				Mapa[linha][coluna].setChecked(true);
				Mapa[linha][coluna].setOccupied(true);
				return bonecoNaoPreto;
			} else {
				Button.LEDPattern(1);
				Mapa[linha][coluna].setChecked(true);
				return bonecoPreto;
			}
		} else {
			Navegacao.setVelocidade(velocidadeMaior);
			Mapa[linha][coluna].setChecked(true);
			Button.LEDPattern(0);
			return vazio;
		}
	}

	/**
	 * Inicializa o mapa com todas as posicoes ocupadas
	 */
	public static void inicializarMapa() {
		for (int i = 0; i < numLinhas; i++) {
			for (int j = 0; j < numColunas; j++) {
				Mapa[i][j] = new Celula(new Posicao(i, j));
				Mapa[i][j].setChecked(false);
				Mapa[i][j].setOccupied(true);
			}
		}
		MapaCentral = Mapa;
		MapaPeriferico1 = Mapa;
		MapaPeriferico2 = Mapa;
	}

	/**
	 * Retorna para a posicao desejada, pelo menor caminho possível
	 * 
	 * @param Posicao
	 *            objetivo
	 */

	private static void retornar(Posicao objetivo) throws Exception {
		Astar aStar = new Astar(Mapa);
		atual = Mapa[linha][coluna].getPosicao();

		if (resgatando) {
			if (salaAtual == SALACENTRAL) {
				ultMapeadaCentral = atual;
				ultOrientacaoCentral = Navegacao.orientacaoAtual;
			} else if (salaAtual == SALAPERIFERICA) {
				ultMapeadaPeriferica = atual;
				ultOrientacaoPeriferica = Navegacao.orientacaoAtual;
			}
		}

		List<Celula> caminho = aStar.search(atual, objetivo);
		// Percorre o menor caminho encontrado
		for (int i = 0; i < caminho.size(); i++) {
			atual = Mapa[linha][coluna].getPosicao();
			resetarProxCelulas();
			if (caminho.get(i).getPosicao().y == atual.y) {
				if (caminho.get(i).getPosicao().x < atual.x) {
					celulaEsq = true;
				} else {
					celulaDir = true;
				}
			} else if (caminho.get(i).getPosicao().x == atual.x) {
				if (caminho.get(i).getPosicao().y < atual.y) {
					celulaBaixo = true;
				} else {
					celulaCima = true;
				}
			}
			fazerManobra(); // Faz a manobra necessaria para ir à celula
							// desejada
			if (((linha == 0 && Navegacao.orientacaoAtual == Navegacao.LESTE)
					|| (linha == 8 && Navegacao.orientacaoAtual == Navegacao.OESTE)
					|| (coluna == 8 && Navegacao.orientacaoAtual == Navegacao.SUL) || (coluna == 0 && Navegacao.orientacaoAtual == Navegacao.NORTE))
					&& coluna != 4 && linha != 4) {
				Navegacao.alinhar();
				Navegacao.setAngAnterior(Navegacao.getAnguloAtual());
			}
			irProximaCelula();
			atualizarCelulas();
		}

		if (resgatando && salaAtual == SALAPERIFERICA) {
			ultSala = SALAPERIFERICA;
			if (perifericaDireita) {
				switch (Navegacao.orientacaoAtual) {
				case Navegacao.SUL:
					Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
					break;
				case Navegacao.NORTE:
					Navegacao.virarDuasRodasEsq(angCurva, velocidadeMenor);
					break;
				default:
					break;
				}
			} else if (perifericaEsquerda) {
				switch (Navegacao.orientacaoAtual) {
				case Navegacao.NORTE:
					Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
					break;
				case Navegacao.SUL:
					Navegacao.virarDuasRodasEsq(angCurva, velocidadeMenor);
					break;
				default:
					break;
				}
			} else {
				switch (Navegacao.orientacaoAtual) {
				case Navegacao.LESTE:
					Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
					break;
				case Navegacao.OESTE:
					Navegacao.virarDuasRodasEsq(angCurva, velocidadeMenor);
					break;
				default:
					break;
				}
			}
			Navegacao.irProxSala();
			atualizarSala();
			retornar(inicio);
		}

		if (resgatando) {
			deixarBonecoDestino();
			resgatando = false;
			retornandoMapeamento = true;
			retornar(ultMapeadaCentral);
			if (ultSala == SALAPERIFERICA) {
				Navegacao.irProxSala();
				atualizarSala();
				retornar(ultMapeadaPeriferica);
				if (Navegacao.orientacaoAtual != ultOrientacaoPeriferica)
					mudarOrientacao(ultOrientacaoPeriferica);
			} else {
				mudarOrientacao(ultOrientacaoCentral);
			}
			retornandoMapeamento = false;
		}
	}

	/**
	 * Anda até a proxima celula
	 */
	public static void irProximaCelula() throws Exception {
		Navegacao.setVelocidade(velocidadeMaior);
		long tempoInicio = System.currentTimeMillis();
		double angAnterior = Navegacao.getAngAnterior();
		double distanciaPercorrida = Navegacao.getDistPercorrida();
		while (distanciaPercorrida <= tamanhoDaCelula) {
			Navegacao.andarFrente(angAnterior);
			distanciaPercorrida = Navegacao.getDistPercorrida();
			if ((System.currentTimeMillis() - tempoInicio) > 5000) {
				Navegacao.parar();
				Navegacao.ré();
				Delay.msDelay(1000);
				Navegacao.parar();
				Navegacao.resetarTacometro();
				tempoInicio = System.currentTimeMillis();
			}
		}
		Navegacao.resetarTacometro();
	}

	/**
	 * Seta os booleans das proximas celulas como false
	 */
	private static void resetarProxCelulas() {
		celulaBaixo = false;
		celulaCima = false;
		celulaEsq = false;
		celulaDir = false;
	}

	/**
	 * Voltar para a ultima orientacao
	 */

	private static void mudarOrientacao(int orientacao) {
		switch (orientacao) {
		case (Navegacao.LESTE):
			switch (Navegacao.orientacaoAtual) {
			case (Navegacao.NORTE):
				Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
				break;
			case (Navegacao.OESTE):
				Navegacao.virarDuasRodasEsq(angCurva, velocidadeMenor);
				Navegacao.virarDuasRodasEsq(angCurva, velocidadeMenor);
				break;
			case (Navegacao.SUL):
				Navegacao.virarDuasRodasEsq(angCurva, velocidadeMenor);
				break;
			}
			Navegacao.orientacaoAtual = Navegacao.LESTE;
			break;
		case (Navegacao.OESTE):
			switch (Navegacao.orientacaoAtual) {
			case (Navegacao.NORTE):
				Navegacao.virarDuasRodasEsq(angCurva, velocidadeMenor);
				break;
			case (Navegacao.LESTE):
				Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
				Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
				break;
			case (Navegacao.SUL):
				Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
				break;
			}
			Navegacao.orientacaoAtual = Navegacao.OESTE;
			break;
		case (Navegacao.NORTE):
			switch (Navegacao.orientacaoAtual) {
			case (Navegacao.OESTE):
				Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
				break;
			case (Navegacao.LESTE):
				Navegacao.virarDuasRodasEsq(angCurva, velocidadeMenor);
				break;
			case (Navegacao.SUL):
				Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
				Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
				break;
			}
			Navegacao.orientacaoAtual = Navegacao.NORTE;
			break;

		case (Navegacao.SUL):
			switch (Navegacao.orientacaoAtual) {
			case (Navegacao.OESTE):
				Navegacao.virarDuasRodasEsq(angCurva, velocidadeMenor);
				break;
			case (Navegacao.LESTE):
				Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
				break;
			case (Navegacao.NORTE):
				Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
				Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
				break;
			}
			Navegacao.orientacaoAtual = Navegacao.SUL;
			break;
		}
		Navegacao.setVelocidade(velocidadeMaior);
	}

	/**
	 * Deixar o boneco no modulo inicial
	 * 
	 * @throws Exception
	 */

	private static void deixarBonecoDestino() throws Exception {
		switch (Navegacao.orientacaoAtual) {
		case Navegacao.LESTE:
			Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
			break;
		case Navegacao.OESTE:
			Navegacao.virarDuasRodasEsq(angCurva, velocidadeMenor);
			break;
		case Navegacao.NORTE:
			Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
			Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
		default:
			break;
		}
		if (salaAtual == SALACENTRAL) {
			Navegacao.irProxSala();
			Delay.msDelay(1000);
			atualizarSala();
			Navegacao.parar();
			Captura.abrirGarra();
			while (!Navegacao.mudouDeSala)
				Navegacao.ré();
			Delay.msDelay(500);
			resgatando = false;
			atualizarSala();
			Navegacao.resetarTacometro();
		}
	}

	/**
	 * Faz a manobra necessaria para ir para a celula desejada
	 */
	private static void fazerManobra() {
		switch (Navegacao.orientacaoAtual) {
		case Navegacao.LESTE:
			if (celulaEsq) {
				Navegacao.parar();
				if (coluna == 0) {
					Navegacao.virarDuasRodasEsq(angCurva, velocidadeMenor);
					Navegacao.virarDuasRodasEsq(angCurva, velocidadeMenor);
				} else {
					Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
					Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
				}
			} else if (celulaDir) {
				Navegacao.setVelocidade(velocidadeMaior);
			} else if (celulaCima) {
				Navegacao.parar();
				Navegacao.virarDuasRodasEsq(angCurva, velocidadeMenor);
			} else if (celulaBaixo) {
				Navegacao.parar();
				Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
			}
			break;
		case Navegacao.OESTE:
			if (celulaEsq) {
				Navegacao.setVelocidade(velocidadeMaior);
			} else if (celulaDir) {
				Navegacao.parar();
				if (coluna == 0) {
					Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
					Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
				} else
					Navegacao.virarDuasRodasEsq(angCurva, velocidadeMenor);
				Navegacao.virarDuasRodasEsq(angCurva, velocidadeMenor);

				Navegacao.orientacaoAtual = Navegacao.LESTE;
			} else if (celulaCima) {
				Navegacao.parar();
				Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
			} else if (celulaBaixo) {
				Navegacao.parar();
				Navegacao.virarDuasRodasEsq(angCurva, velocidadeMenor);
			}
			break;
		case Navegacao.NORTE:
			if (celulaEsq) {
				Navegacao.parar();
				Navegacao.virarDuasRodasEsq(angCurva, velocidadeMenor);
			} else if (celulaDir) {
				Navegacao.parar();
				Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
			} else if (celulaCima) {
				Navegacao.setVelocidade(velocidadeMaior);
			} else if (celulaBaixo) {
				Navegacao.parar();
				if (linha == 0) {
					Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
					Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
				} else {
					Navegacao.virarDuasRodasEsq(angCurva, velocidadeMenor);
					Navegacao.virarDuasRodasEsq(angCurva, velocidadeMenor);
				}
				Navegacao.orientacaoAtual = Navegacao.SUL;
			}
			break;
		case Navegacao.SUL:
			if (celulaEsq) {
				Navegacao.parar();
				Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
			} else if (celulaDir) {
				Navegacao.parar();
				Navegacao.virarDuasRodasEsq(angCurva, velocidadeMenor);
			} else if (celulaCima) {
				Navegacao.parar();
				if (linha == 0) {
					Navegacao.virarDuasRodasEsq(angCurva, velocidadeMenor);
					Navegacao.virarDuasRodasEsq(angCurva, velocidadeMenor);
				} else {
					Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
					Navegacao.virarDuasRodasDir(angCurva, velocidadeMenor);
				}
				Navegacao.orientacaoAtual = Navegacao.NORTE;
			} else if (celulaBaixo) {
				Navegacao.setVelocidade(velocidadeMaior);
			}
			break;
		default:
			break;
		}
	}

}
